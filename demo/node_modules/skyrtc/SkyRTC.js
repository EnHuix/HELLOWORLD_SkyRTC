var WebSocketServer = require('ws').Server;
var UUID = require('node-uuid');
var events = require('events');
var util = require('util');
const Cookies = require('cookies');

/*
//定义一个匹配池，将所有处在匹配状态的用户存在该池中，用于匹配
该池子用于写demo
var match_pool=[];

//定义一个房间名的池子，用来存储成功的房间名
var match_success_room=[];

//每次匹配时，根据当前用户选择的语言分别进入不同的匹配池
var match_pool_cn=[],
	match_pool_en=[];

//设置一个bool值，用来加锁，应该为每个匹配池都设置一个bool来加锁
var lock=false;

//定义一个匹配成功后组成的房间名，用于偶数序号的用户去查找自己是否匹配成功，并找到自己的房间名，找到后即可删除该房间名，并返回到前端页面

//得到自己的匹配成功的房间名
function get_my_room(pool,user){

	//加到相应的池子中
	add_to_pool(pool,user);
	var result=match_connection(pool,user);
	console.log(result);
	return result;
}

//匹配函数
//匹配思想想不出比较合理的
//为每一个用户给出一个顺序，偶数的去匹配，奇数的去等待，匹配成功后，返回一个两个人名字组成的房间名

//感觉要给匹配池加锁，现在写了一个简单的加锁（即用bool值来判断），但不知道对不对
function match_connection(pool,user){
	
	var talk_room="";
	//去池中找到一个人，找到后则生成一个房间名
	//如果自己先被匹配到，则直接
	if(!lock){
		lock=true;
		if(pool.indexOf(user)%2==0){	//为偶数，则去匹配
			var index;
			while(1){
				index=Math.ceil(Math.random()*pool.length);
				if(index<pool.length && index%2!=0 ){
					
					talk_room+=user.name+pool[index].name;	//得到房间名

					//将两位用户移出匹配池
					remove_from_pool(pool,user);	
					remove_from_pool(pool,pool[index]);
					
					lock=false;	//对共享数据区解锁
					

					return talk_room;
				}
			}
			
		}else{ //为奇数，则等待  （有bug，如果有三个人在等待，第三个人则需要一直等）
			while(1){
				if(match_success_room.length!=0){
					var match_success=false;
					var room_name="";
					for(var i=0;i<match_success_room.length;i++){
						if(match_success_room[i].indexOf(user.socketUser.name)!=-1){
							match_success=true;
							room_name=match_success_room[i];
							break;
						}
					}
					if(match_success){
						return room_name;
					}
				}

			}
		}
	}else{
		//如果此时上锁，就重复调用自身，直至等待到解锁（这儿有一个疑问，假如用户特别多，该等待匹配用户一直在等待，一直调用这个函数，会不会导致栈溢出）
		match_connection(pool,user);
	}
	
}

// 将匹配用户加入匹配池
function add_to_pool(pool,user){
	pool.push(user);
	console.log(match_pool);
}

//匹配成功后移除匹配池
function remove_from_pool(pool,user){

	for(var i=0;i<match_pool.length;++i){
		if(match_pool[i].id==user.id){
			matchMedia.pool.splice(i,1);
			break;
		}
	}
}
*/


//加一个匹配池的感觉不太好写，换一种思想
//设置一个房间队列，每次有人请求匹配时，如果房间队列为空，则生成一个房间，加入到房间队列（房间是一个字典，包括语言类型，人数（人数只能有两个））
//另一个人请求匹配的时候，先查看是否有房间（满足语言要求），如果有房间，则加入该房间，房间满两个人，则将该房间从队列中删除

var room_queue=[];
function match_connection(){
	var room_name="";
	if(room_queue.length==0){
		room_name=UUID.v1();
		var room_object={
			"room_name":room_name,
			"num_of_user":1
		}
		room_queue.push(room_object);
		return room_name;
	}else{
		var i=0;
		console.log(room_queue)
		//for(i=0;i<room_queue.length;i++){
			/*if(room_queue[i]){
				这里写判断语言的种类的逻辑
			}*/
		//}
		// console.log(room_queue[0].room_name)
		room_name=room_queue[i].room_name;
		//b873afa0-56a6-11e9-939a-f7e49165f874

		//room_queue.splice(i,1);

		return room_name;

	}

}



var errorCb = function(rtc) {
	return function(error) {
		if (error) {
			rtc.emit("error", error);
		}
	};
};


function SkyRTC() {
	this.sockets = [];
	this.rooms = {};
	this.on('__join', function(data, socket) {
		
		//console.log(data);
		var ids = [],
			users=[],
			i, m,
			room = data.room || "__default",
			curSocket,
			curRoom;
		

		let user = parseUser(socket.upgradeReq);
		socket.user=user;
		// console.log(socket.user)	

		curRoom = this.rooms[room] = this.rooms[room] || [];
		
		
		for (i = 0, m = curRoom.length; i < m; i++) {
			curSocket = curRoom[i];
			if (curSocket.id === socket.id) {
				continue;
			}
			ids.push(curSocket.id);
			curSocket.send(JSON.stringify({
				"eventName": "_new_peer",
				"data": {
					"socketId": socket.id,
					"socketUser":socket.user,
					"room": room
				}
			}), errorCb);
		}

		curRoom.push(socket);
		socket.room = room;
		

		for (i = 0, m = curRoom.length; i < m; i++) {
			curSocket = curRoom[i];
			users.push(curSocket.user);
		}
		
		//每次用户连接时，curRoom里的用户已变为原来的加上自己，我们只需把这个用户数组users传回去，即可让每个新的用户的用户列表都相同
		socket.send(JSON.stringify({
			"eventName": "_peers",
			"data": {
				"connections": ids,
				"you": socket.id,
				"user":socket.user,
				"users":users
			}
		}), errorCb);
	
		this.emit('new_peer', socket, room);
	});

	this.on('__ice_candidate', function(data, socket) {
		var soc = this.getSocket(data.socketId);

		if (soc) {
			soc.send(JSON.stringify({
				"eventName": "_ice_candidate",
				"data": {
					"label": data.label,
					"candidate": data.candidate,
					"socketId": socket.id
				}
			}), errorCb);

			this.emit('ice_candidate', socket, data);
		}
	});

	this.on('__offer', function(data, socket) {
		var soc = this.getSocket(data.socketId);

		if (soc) {
			soc.send(JSON.stringify({
				"eventName": "_offer",
				"data": {
					"sdp": data.sdp,
					"socketId": socket.id
				}
			}), errorCb);
		}
		this.emit('offer', socket, data);
	});

	this.on('__answer', function(data, socket) {
		var soc = this.getSocket(data.socketId);
		if (soc) {
			soc.send(JSON.stringify({
				"eventName": "_answer",
				"data": {
					"sdp": data.sdp,
					"socketId": socket.id
				}
			}), errorCb);
			this.emit('answer', socket, data);
		}
	});

	this.on('_match',function(data){
		
		// console.log(data.socketId)
		// console.log(data.socketUser)

		// if(user){
			/*
				这里写根据用户选择的想学习的语言种类
				选择把用户加到哪一个匹配池的逻辑
			*/
		// }
		
		// var result=get_my_room(match_pool,data.socketUser);
		
		var room_name=match_connection();

		var soc = this.getSocket(data.socketId);
		if (soc) {
			soc.send(JSON.stringify({
				"eventName": "_get_room",
				"data": {
					"room_name":room_name
				}
			}), errorCb);
			// this.emit('answer', socket, data);
		}

		//this.emit('get_roomname', room_name);
		console.log(room_name);
	});

}

util.inherits(SkyRTC, events.EventEmitter);

SkyRTC.prototype.addSocket = function(socket) {
	this.sockets.push(socket);
};

SkyRTC.prototype.removeSocket = function(socket) {
	var i = this.sockets.indexOf(socket),
		room = socket.room;
	this.sockets.splice(i, 1);
	if (room) {
		i = this.rooms[room].indexOf(socket);
		this.rooms[room].splice(i, 1);
		if (this.rooms[room].length === 0) {
			delete this.rooms[room];
		}
	}
};

SkyRTC.prototype.broadcast = function(data, errorCb) {
	var i;
	for (i = this.sockets.length; i--;) {
		this.sockets[i].send(data, errorCb);
	}
};

SkyRTC.prototype.broadcastInRoom = function(room, data, errorCb) {
	var curRoom = this.rooms[room],
		i;
	if (curRoom) {
		for (i = curRoom.length; i--;) {
			curRoom[i].send(data, errorCb);
		}
	}
};

SkyRTC.prototype.getRooms = function() {
	var rooms = [],
		room;
	for (room in this.rooms) {
		rooms.push(room);
	}
	return rooms;
};

SkyRTC.prototype.getSocket = function(id) {
	var i,
		curSocket;
	if (!this.sockets) {
		return;
	}
	for (i = this.sockets.length; i--;) {
		curSocket = this.sockets[i];
		if (id === curSocket.id) {
			return curSocket;
		}
	}
	return;
};

SkyRTC.prototype.init = function(socket) {
	var that = this;
	socket.id = UUID.v4();
	
	
	
	that.addSocket(socket);
	//为新连接绑定事件处理器
	socket.on('message', function(data) {
		//console.log(data);
		var json = JSON.parse(data);
		console.log(json)
		if (json.eventName) {
			that.emit(json.eventName, json.data, socket);
		} else {
			that.emit("socket_message", socket, data);
		}
	});
	//连接关闭后从SkyRTC实例中移除连接，并通知其他连接
	socket.on('close', function() {
		var i, m,
			room = socket.room,
			curRoom;
		
		// console.log("退出了")
		if (room) {
			curRoom = that.rooms[room];
			for (i = curRoom.length; i--;) {
				if (curRoom[i].id === socket.id) {
					continue;
				}
				curRoom[i].send(JSON.stringify({
					"eventName": "_remove_peer",
					"data": {
						"socketId": socket.id,
						"socketUser":socket.user
					}
				}), errorCb);
			}
		}

		that.removeSocket(socket);

		that.emit('remove_peer', socket.id,socket.user,that);
	});
	
	that.emit('new_connect', socket,socket.id,socket.user);
	that.emit('broadcast', socket);
};

function parseUser(obj) {
    if (!obj) {
        return;
    }
    console.log('try parse: ' + obj);
    let s = '';
    if (typeof obj === 'string') {
        s = obj;
    } else if (obj.headers) {
        let cookies = new Cookies(obj, null);
        s = cookies.get('name');
    }
    if (s) {
        try {
            let user = JSON.parse(Buffer.from(s, 'base64').toString());
            console.log(`User: ${user.name}, ID: ${user.id}`);
            return user;
        } catch (e) {
            // ignore
        }
    }
}

module.exports.listen = function(server) {
	var SkyRTCServer;
	if (typeof server === 'number') {
		SkyRTCServer = new WebSocketServer({
			port: server
		});
	} else {
		SkyRTCServer = new WebSocketServer({
			server: server
		});
	}

	
	SkyRTCServer.rtc = new SkyRTC();
	errorCb = errorCb(SkyRTCServer.rtc);
	SkyRTCServer.on('connection', function(socket) {
		
		this.rtc.init(socket);
	});

	return SkyRTCServer;
};